# 2022-09-07 - ðŸš€ It works!

## ðŸƒâ€â™‚ï¸ Reculer pour mieux sauter

Dans Fastify, il n'est (toujours) pas possible d'ajouter des routes ou des plugins Ã  la volÃ©e (cf. [issue #149](https://github.com/fastify/help/issues/149)).

Dans mon cas, ce n'est pas si grave. 
Si une app se fait proxifiÃ©e une fois, si jamais elle doit Ãªtre rÃ©veillÃ©e, au moins le routage sera prÃªt.

Mais il me vient une rÃ©flexion : si on ne peut pas proxifier des routes/apps Ã  la volÃ©e, comment manager de nouvelles apps, pas prÃ©sentes au dÃ©marrage ?

Pistes :
- Peut-Ãªtre que `@fastify/http-proxy`, de par son comportement basÃ© sur les prefix de requÃªtes, permet de le faire
- Peut-Ãªtre que je vais vraiment devoir faire le proxy Ã  la main (et bye-bye la semi-gestion des WebSockets)

Mais du coup, quite Ã  faire un simple proxy_pass, pourquoi s'embÃªter avec Nginx ðŸ¤”

> âš ï¸ Quid des requÃªtes de fichier / multipart / stream ?

Et si le plus simple Ã©tait de passer directement par [`fastify-reply-from`](https://github.com/fastify/fastify-reply-from) ? 
Comme Ã§a plus de besoin de Nginx.
Et je rÃ©cupÃ¨re directement le app_name (via tldts).
Testons.

## ðŸ”® L'Oracle

Call avec JOP
https://publicsuffix.org/
proposer Ã  Scalingo de faire comme Heroku et proposer un Public Suffix
pour tous les hÃ©bergeurs qui revendent des sous-domaines, permet de protÃ©ger 2 sites hÃ©bergÃ©s qui n'ont rien Ã  voir

J'ai zappÃ© le cas oÃ¹ une RA est crÃ©Ã©e (90% des cas).
Et tant que je n'essaye pas d'y accÃ©der, elle ne sera pas managÃ©e.
Mais du coup, mon truc ne sert Ã  rien en l'Ã©tat.
Il me faut absolument poller l'API de Scalingo rÃ©guliÃ¨rement.
Toutes les minutes.

## ðŸ‘‹ Bye-bye Fastify, hello `node-http-proxy`

Mettre un Nginx en frontal d'un serveur Fastify, via le plugin `@fastify/http-proxy` est Ã  la fois overkill (2 composants indÃ©pendants dans un langage diffÃ©rent) et contraignant (le fait de ne pouvoir ajouter des routes Ã  la volÃ©e).
Utiliser `@fastify/reply-from`, la lib sous-jacente Ã  `@fastify/http-proxy` complexifie encore plus la chose.
Sachant que dans le tout, on n'a pas un support complet des Web Sockets.
MÃªme si dans les faits, je ne pense pas que tant de projets utilisent les ws.
Finalement, le fait de passer par un serveur Web un "haut niveau" (tout est relatif) est un frein plus qu'une aide.

Jonathan me propose d'utiliser le module Node natif `http` et la lib `node-http-proxy`, en particulier [cet exemple](https://github.com/http-party/node-http-proxy#setup-a-stand-alone-proxy-server-with-custom-server-logic).
L'un des avantages, c'est que cette fois on a toute latitude pour choisir une cible Ã  la volÃ©e.
ðŸ™Œ Avec cette solution, plus besoin de Nginx ni de Fastify !

ðŸŽ‰ Rapidement, on obtient un rÃ©sultat qui fonctionne. Yeah !!!

Node propose un exemple dans la documentation officielle pour faire un proxy.
Mais on est vraiment trÃ¨s bas niveau, trop.
`node-http-proxy` propose [tout un tas d'options](https://github.com/http-party/node-http-proxy#options) bien pratiques comme `changeOrigin`, `hostRewrite` ou `protocolRewrite`.  

Finalement, pas besoin d'utiliser `tldts` pour parser l'URL.
Un coup de `String.replace()` suffit.
ðŸ’ª En plus, Ã§a supporte `localhost:port`. 

> ðŸ’¡ Pour tester en local, sans avoir Ã  s'embÃªter avec le `/etc/hosts`, il suffit de prÃ©ciser le header `Host` avec cURL :
> ```
> $ curl -v http://localhost:3000 -H Host:hello-fastify.gateway.paastis.io
> ```

```shell
$ scalingo -a hello-fastify scale web:0 && sleep 2 ; curl -v http://localhost:3000 -H Host:hello-fastify.gateway.paastis.io
```

## ðŸ“– Registre des applications actives

Maintenant que c'est ok pour le proxy (note : renommer "gateway" en proxy") je peux passer Ã  la gestion des apps Scalingo Ã  proprement parler.

Dans les grandes lignes, il s'agit surtout d'une simple map `Map<appName:String, appData:ManagedApp>`.
